name: Check Compose File Updates

on:
  schedule:
    - cron: '0 0 * * 0'  # Run weekly on Sunday at midnight UTC
  workflow_dispatch:  # Allow manual triggering

jobs:
  check-updates:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Install dependencies
        run: npm install node-fetch
        
      - name: Check for updates
        run: |
          node << 'EOF'
          const fetch = require('node-fetch');
          const fs = require('fs');
          const path = require('path');
          
          // Dynamically discover compose files and their sources
          function discoverComposeFiles() {
            const files = [];
            const composeExtensions = ['.yaml', '.yml'];
            
            // Get all files in current directory
            const allFiles = fs.readdirSync('.');
            
            for (const file of allFiles) {
              const ext = path.extname(file);
              if (composeExtensions.includes(ext)) {
                try {
                  const content = fs.readFileSync(file, 'utf8');
                  const lines = content.split('\n');
                  
                  // Extract source URLs from comments
                  for (const line of lines) {
                    const match = line.match(/^\s*#\s*(https?:\/\/[^\s]+)/);
                    if (match) {
                      const url = match[1];
                      // Convert GitHub URLs to raw URLs if needed
                      let rawUrl = url;
                      if (url.includes('github.com') && url.includes('/blob/')) {
                        rawUrl = url
                          .replace('github.com', 'raw.githubusercontent.com')
                          .replace('/blob/', '/');
                      }
                      
                      files.push({
                        local: file,
                        original: rawUrl,
                        name: path.basename(file, ext)
                      });
                    }
                  }
                } catch (error) {
                  console.error(`Error reading ${file}:`, error.message);
                }
              }
            }
            
            return files;
          }
          
          const composeFiles = discoverComposeFiles();
          
          let updatesFound = false;
          let message = 'üîÑ Compose File Updates Check\n\n';
          
          for (const file of composeFiles) {
            try {
              console.log(`Checking ${file.name}...`);
              
              // Fetch original file
              const response = await fetch(file.original);
              if (!response.ok) {
                console.log(`Failed to fetch ${file.original}: ${response.status}`);
                continue;
              }
              
              const originalContent = await response.text();
              const localContent = fs.readFileSync(file.local, 'utf8');
              
              // Compare content (ignoring comments and whitespace)
              const normalizeContent = (content) => {
                return content
                  .split('\n')
                  .filter(line => !line.trim().startsWith('#'))
                  .map(line => line.trim())
                  .filter(line => line.length > 0)
                  .join('\n');
              };
              
              const normalizedOriginal = normalizeContent(originalContent);
              const normalizedLocal = normalizeContent(localContent);
              
              if (normalizedOriginal !== normalizedLocal) {
                updatesFound = true;
                message += `‚ö†Ô∏è ${file.name} has updates available!\n`;
                message += `   Original: ${file.original}\n`;
                message += `   Local: ${file.local}\n\n`;
              } else {
                message += `‚úÖ ${file.name} is up to date\n`;
              }
              
            } catch (error) {
              console.error(`Error checking ${file.name}:`, error.message);
              message += `‚ùå Error checking ${file.name}: ${error.message}\n\n`;
            }
          }
          
          if (!updatesFound) {
            message += '\nüéâ All compose files are up to date!';
          }
          
          // Create issue if updates found
          if (updatesFound) {
            const issueTitle = 'Compose File Updates Available';
            const issueBody = message + '\n\n---\n*This issue was automatically generated by GitHub Actions*';
            
            // Check if issue already exists
            const existingIssues = await fetch('https://api.github.com/repos/${{ github.repository }}/issues?state=open&labels=compose-updates', {
              headers: {
                'Authorization': `token ${{ secrets.GITHUB_TOKEN }}`,
                'Accept': 'application/vnd.github.v3+json'
              }
            });
            
            if (existingIssues.ok) {
              const issues = await existingIssues.json();
              if (issues.length === 0) {
                // Create new issue
                const createIssue = await fetch('https://api.github.com/repos/${{ github.repository }}/issues', {
                  method: 'POST',
                  headers: {
                    'Authorization': `token ${{ secrets.GITHUB_TOKEN }}`,
                    'Accept': 'application/vnd.github.v3+json',
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({
                    title: issueTitle,
                    body: issueBody,
                    labels: ['compose-updates', 'automation']
                  })
                });
                
                if (createIssue.ok) {
                  const issue = await createIssue.json();
                  console.log(`Created issue: ${issue.html_url}`);
                } else {
                  console.error('Failed to create issue');
                }
              } else {
                // Update existing issue
                const issueNumber = issues[0].number;
                const updateIssue = await fetch(`https://api.github.com/repos/${{ github.repository }}/issues/${issueNumber}`, {
                  method: 'PATCH',
                  headers: {
                    'Authorization': `token ${{ secrets.GITHUB_TOKEN }}`,
                    'Accept': 'application/vnd.github.v3+json',
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({
                    body: issueBody
                  })
                });
                
                if (updateIssue.ok) {
                  console.log(`Updated issue: ${issues[0].html_url}`);
                } else {
                  console.error('Failed to update issue');
                }
              }
            }
          }
          
          // Output result for logs
          console.log(message);
          EOF
          
      - name: Comment on issue if updates found
        if: success()
        run: |
          # This step ensures the workflow output is visible in logs
          echo "Check completed. See logs above for details."